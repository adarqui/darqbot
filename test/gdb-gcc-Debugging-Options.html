   Link: start: Top
   Link: up: Invoking GCC
   Link: prev: Warning Options
   Link: next: Optimize Options
   Link: generator-home: Texinfo Homepage

   Next: Optimize Options, Previous: Warning Options, Up: Invoking GCC

     ----------------------------------------------------------------------------------------------------------------------

  3.9 Options for Debugging Your Program or GCC

   GCC has various special options that are used for debugging either your program or GCC:

   -g
           Produce debugging information in the operating system's native format (stabs, COFF, XCOFF, or DWARF 2). GDB can
           work with this debugging information.

           On most systems that use stabs format, -g enables use of extra debugging information that only GDB can use; this
           extra information makes debugging work better in GDB but probably makes other debuggers crash or refuse to read
           the program. If you want to control for certain whether to generate the extra information, use -gstabs+, -gstabs,
           -gxcoff+, -gxcoff, or -gvms (see below).

           GCC allows you to use -g with -O. The shortcuts taken by optimized code may occasionally produce surprising
           results: some variables you declared may not exist at all; flow of control may briefly move where you did not
           expect it; some statements may not be executed because they compute constant results or their values are already
           at hand; some statements may execute in different places because they have been moved out of loops.

           Nevertheless it proves possible to debug optimized output. This makes it reasonable to use the optimizer for
           programs that might have bugs.

           The following options are useful when GCC is generated with the capability for more than one debugging format.

   -ggdb
           Produce debugging information for use by GDB. This means to use the most expressive format available (DWARF 2,
           stabs, or the native format if neither of those are supported), including GDB extensions if at all possible.

   -gstabs
           Produce debugging information in stabs format (if that is supported), without GDB extensions. This is the format
           used by DBX on most BSD systems. On MIPS, Alpha and System V Release 4 systems this option produces stabs
           debugging output that is not understood by DBX or SDB. On System V Release 4 systems this option requires the GNU
           assembler.

   -feliminate-unused-debug-symbols
           Produce debugging information in stabs format (if that is supported), for only symbols that are actually used.

   -femit-class-debug-always
           Instead of emitting debugging information for a C++ class in only one object file, emit it in all object files
           using the class. This option should be used only with debuggers that are unable to handle the way GCC normally
           emits debugging information for classes because using this option increases the size of debugging information by
           as much as a factor of two.

   -fdebug-types-section
           When using DWARF Version 4 or higher, type DIEs can be put into their own .debug_types section instead of making
           them part of the .debug_info section. It is more efficient to put them in a separate comdat sections since the
           linker can then remove duplicates. But not all DWARF consumers support .debug_types sections yet and on some
           objects .debug_types produces larger instead of smaller debugging information.

   -gstabs+
           Produce debugging information in stabs format (if that is supported), using GNU extensions understood only by the
           GNU debugger (GDB). The use of these extensions is likely to make other debuggers crash or refuse to read the
           program.

   -gcoff
           Produce debugging information in COFF format (if that is supported). This is the format used by SDB on most System
           V systems prior to System V Release 4.

   -gxcoff
           Produce debugging information in XCOFF format (if that is supported). This is the format used by the DBX debugger
           on IBM RS/6000 systems.

   -gxcoff+
           Produce debugging information in XCOFF format (if that is supported), using GNU extensions understood only by the
           GNU debugger (GDB). The use of these extensions is likely to make other debuggers crash or refuse to read the
           program, and may cause assemblers other than the GNU assembler (GAS) to fail with an error.

   -gdwarf-version
           Produce debugging information in DWARF format (if that is supported). The value of version may be either 2, 3 or
           4; the default version for most targets is 4.

           Note that with DWARF Version 2, some ports require and always use some non-conflicting DWARF 3 extensions in the
           unwind tables.

           Version 4 may require GDB 7.0 and -fvar-tracking-assignments for maximum benefit.

   -grecord-gcc-switches
           This switch causes the command-line options used to invoke the compiler that may affect code generation to be
           appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces
           separating them from each other and from the compiler version. See also -frecord-gcc-switches for another way of
           storing compiler options into the object file. This is the default.

   -gno-record-gcc-switches
           Disallow appending command-line options to the DW_AT_producer attribute in DWARF debugging information.

   -gstrict-dwarf
           Disallow using extensions of later DWARF standard version than selected with -gdwarf-version. On most targets
           using non-conflicting DWARF extensions from later standard versions is allowed.

   -gno-strict-dwarf
           Allow using extensions of later DWARF standard version than selected with -gdwarf-version.

   -gvms
           Produce debugging information in Alpha/VMS debug format (if that is supported). This is the format used by DEBUG
           on Alpha/VMS systems.

   -glevel

   -ggdblevel

   -gstabslevel

   -gcofflevel

   -gxcofflevel

   -gvmslevel
           Request debugging information and also use level to specify how much information. The default level is 2.

           Level 0 produces no debug information at all. Thus, -g0 negates -g.

           Level 1 produces minimal information, enough for making backtraces in parts of the program that you don't plan to
           debug. This includes descriptions of functions and external variables, but no information about local variables
           and no line numbers.

           Level 3 includes extra information, such as all the macro definitions present in the program. Some debuggers
           support macro expansion when you use -g3.

           -gdwarf-2 does not accept a concatenated debug level, because GCC used to support an option -gdwarf that meant to
           generate debug information in version 1 of the DWARF format (which is very different from version 2), and it would
           have been too confusing. That debug format is long obsolete, but the option cannot be changed now. Instead use an
           additional -glevel option to change the debug level for DWARF.

   -gtoggle
           Turn off generation of debug info, if leaving out this option generates it, or turn it on at level 2 otherwise.
           The position of this argument in the command line does not matter; it takes effect after all other options are
           processed, and it does so only once, no matter how many times it is given. This is mainly intended to be used with
           -fcompare-debug.

   -fdump-final-insns[=file]
           Dump the final internal representation (RTL) to file. If the optional argument is omitted (or if file is .), the
           name of the dump file is determined by appending .gkd to the compilation output file name.

   -fcompare-debug[=opts]
           If no error occurs during compilation, run the compiler a second time, adding opts and -fcompare-debug-second to
           the arguments passed to the second compilation. Dump the final internal representation in both compilations, and
           print an error if they differ.

           If the equal sign is omitted, the default -gtoggle is used.

           The environment variable GCC_COMPARE_DEBUG, if defined, non-empty and nonzero, implicitly enables -fcompare-debug.
           If GCC_COMPARE_DEBUG is defined to a string starting with a dash, then it is used for opts, otherwise the default
           -gtoggle is used.

           -fcompare-debug=, with the equal sign but without opts, is equivalent to -fno-compare-debug, which disables the
           dumping of the final representation and the second compilation, preventing even GCC_COMPARE_DEBUG from taking
           effect.

           To verify full coverage during -fcompare-debug testing, set GCC_COMPARE_DEBUG to say
           `-fcompare-debug-not-overridden', which GCC rejects as an invalid option in any actual compilation (rather than
           preprocessing, assembly or linking). To get just a warning, setting GCC_COMPARE_DEBUG to `-w%n-fcompare-debug not
           overridden' will do.

   -fcompare-debug-second
           This option is implicitly passed to the compiler for the second compilation requested by -fcompare-debug, along
           with options to silence warnings, and omitting other options that would cause side-effect compiler outputs to
           files or to the standard output. Dump files and preserved temporary files are renamed so as to contain the .gk
           additional extension during the second compilation, to avoid overwriting those generated by the first.

           When this option is passed to the compiler driver, it causes the first compilation to be skipped, which makes it
           useful for little other than debugging the compiler proper.

   -feliminate-dwarf2-dups
           Compress DWARF 2 debugging information by eliminating duplicated information about each symbol. This option only
           makes sense when generating DWARF 2 debugging information with -gdwarf-2.

   -femit-struct-debug-baseonly
           Emit debug information for struct-like types only when the base name of the compilation source file matches the
           base name of file in which the struct is defined.

           This option substantially reduces the size of debugging information, but at significant potential loss in type
           information to the debugger. See -femit-struct-debug-reduced for a less aggressive option. See
           -femit-struct-debug-detailed for more detailed control.

           This option works only with DWARF 2.

   -femit-struct-debug-reduced
           Emit debug information for struct-like types only when the base name of the compilation source file matches the
           base name of file in which the type is defined, unless the struct is a template or defined in a system header.

           This option significantly reduces the size of debugging information, with some potential loss in type information
           to the debugger. See -femit-struct-debug-baseonly for a more aggressive option. See -femit-struct-debug-detailed
           for more detailed control.

           This option works only with DWARF 2.

   -femit-struct-debug-detailed[=spec-list]
           Specify the struct-like types for which the compiler generates debug information. The intent is to reduce
           duplicate struct debug information between different object files within the same program.

           This option is a detailed version of -femit-struct-debug-reduced and -femit-struct-debug-baseonly, which serves
           for most needs.

           A specification has the syntax
           [`dir:'|`ind:'][`ord:'|`gen:'](`any'|`sys'|`base'|`none')

           The optional first word limits the specification to structs that are used directly (`dir:') or used indirectly
           (`ind:'). A struct type is used directly when it is the type of a variable, member. Indirect uses arise through
           pointers to structs. That is, when use of an incomplete struct is valid, the use is indirect. An example is
           `struct one direct; struct two * indirect;'.

           The optional second word limits the specification to ordinary structs (`ord:') or generic structs (`gen:').
           Generic structs are a bit complicated to explain. For C++, these are non-explicit specializations of template
           classes, or non-template classes within the above. Other programming languages have generics, but
           -femit-struct-debug-detailed does not yet implement them.

           The third word specifies the source files for those structs for which the compiler should emit debug information.
           The values `none' and `any' have the normal meaning. The value `base' means that the base of name of the file in
           which the type declaration appears must match the base of the name of the main compilation file. In practice, this
           means that when compiling foo.c, debug information is generated for types declared in that file and foo.h, but not
           other header files. The value `sys' means those types satisfying `base' or declared in system or compiler headers.

           You may need to experiment to determine the best settings for your application.

           The default is -femit-struct-debug-detailed=all.

           This option works only with DWARF 2.

   -fno-merge-debug-strings
           Direct the linker to not merge together strings in the debugging information that are identical in different
           object files. Merging is not supported by all assemblers or linkers. Merging decreases the size of the debug
           information in the output file at the cost of increasing link processing time. Merging is enabled by default.

   -fdebug-prefix-map=old=new
           When compiling files in directory old, record debugging information describing them as in new instead.

   -fno-dwarf2-cfi-asm
           Emit DWARF 2 unwind info as compiler generated .eh_frame section instead of using GAS .cfi_* directives.

   -p
           Generate extra code to write profile information suitable for the analysis program prof. You must use this option
           when compiling the source files you want data about, and you must also use it when linking.

   -pg
           Generate extra code to write profile information suitable for the analysis program gprof. You must use this option
           when compiling the source files you want data about, and you must also use it when linking.

   -Q
           Makes the compiler print out each function name as it is compiled, and print some statistics about each pass when
           it finishes.

   -ftime-report
           Makes the compiler print some statistics about the time consumed by each pass when it finishes.

   -fmem-report
           Makes the compiler print some statistics about permanent memory allocation when it finishes.

   -fpre-ipa-mem-report

   -fpost-ipa-mem-report
           Makes the compiler print some statistics about permanent memory allocation before or after interprocedural
           optimization.

   -fstack-usage
           Makes the compiler output stack usage information for the program, on a per-function basis. The filename for the
           dump is made by appending .su to the auxname. auxname is generated from the name of the output file, if explicitly
           specified and it is not an executable, otherwise it is the basename of the source file. An entry is made up of
           three fields:
              * The name of the function.
              * A number of bytes.
              * One or more qualifiers: static, dynamic, bounded.

           The qualifier static means that the function manipulates the stack statically: a fixed number of bytes are
           allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made
           in the function. The second field is this fixed number of bytes.

           The qualifier dynamic means that the function manipulates the stack dynamically: in addition to the static
           allocation described above, stack adjustments are made in the body of the function, for example to push/pop
           arguments around function calls. If the qualifier bounded is also present, the amount of these adjustments is
           bounded at compile time and the second field is an upper bound of the total amount of stack used by the function.
           If it is not present, the amount of these adjustments is not bounded at compile time and the second field only
           represents the bounded part.

   -fprofile-arcs
           Add code so that program flow arcs are instrumented. During execution the program records how many times each
           branch and call is executed and how many times it is taken or returns. When the compiled program exits it saves
           this data to a file called auxname.gcda for each source file. The data may be used for profile-directed
           optimizations (-fbranch-probabilities), or for test coverage analysis (-ftest-coverage). Each object file's
           auxname is generated from the name of the output file, if explicitly specified and it is not the final executable,
           otherwise it is the basename of the source file. In both cases any suffix is removed (e.g. foo.gcda for input file
           dir/foo.c, or dir/foo.gcda for output file specified as -o dir/foo.o). See Cross-profiling.

   --coverage
           This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for
           -fprofile-arcs -ftest-coverage (when compiling) and -lgcov (when linking). See the documentation for those options
           for more details.
              * Compile the source files with -fprofile-arcs plus optimization and code generation options. For test coverage
                analysis, use the additional -ftest-coverage option. You do not need to profile every source file in a
                program.
              * Link your object files with -lgcov or -fprofile-arcs (the latter implies the former).
              * Run the program on a representative workload to generate the arc profile information. This may be repeated
                any number of times. You can run concurrent instances of your program, and provided that the file system
                supports locking, the data files will be correctly updated. Also fork calls are detected and correctly
                handled (double counting will not happen).
              * For profile-directed optimizations, compile the source files again with the same optimization and code
                generation options plus -fbranch-probabilities (see Options that Control Optimization).
              * For test coverage analysis, use gcov to produce human readable information from the .gcno and .gcda files.
                Refer to the gcov documentation for further information.

           With -fprofile-arcs, for each function of your program GCC creates a program flow graph, then finds a spanning
           tree for the graph. Only arcs that are not on the spanning tree have to be instrumented: the compiler adds code to
           count the number of times that these arcs are executed. When an arc is the only exit or only entrance to a block,
           the instrumentation code can be added to the block; otherwise, a new basic block must be created to hold the
           instrumentation code.

   -ftest-coverage
           Produce a notes file that the gcov code-coverage utility (see gcov-a Test Coverage Program) can use to show
           program coverage. Each source file's note file is called auxname.gcno. Refer to the -fprofile-arcs option above
           for a description of auxname and instructions on how to generate test coverage data. Coverage data matches the
           source files more closely if you do not optimize.

   -fdbg-cnt-list
           Print the name and the counter upper bound for all debug counters.

   -fdbg-cnt=counter-value-list
           Set the internal debug counter upper bound. counter-value-list is a comma-separated list of name:value pairs which
           sets the upper bound of each debug counter name to value. All debug counters have the initial upper bound of
           UINT_MAX; thus dbg_cnt() returns true always unless the upper bound is set by this option. For example, with
           -fdbg-cnt=dce:10,tail_call:0, dbg_cnt(dce) returns true only for first 10 invocations.

   -fenable-kind-pass

   -fdisable-kind-pass=range-list
           This is a set of options that are used to explicitly disable/enable optimization passes. These options are
           intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes
           instead.

                -fdisable-ipa-pass
                        Disable IPA pass pass. pass is the pass name. If the same pass is statically invoked in the compiler
                        multiple times, the pass name should be appended with a sequential number starting from 1.

                -fdisable-rtl-pass

                -fdisable-rtl-pass=range-list
                        Disable RTL pass pass. pass is the pass name. If the same pass is statically invoked in the compiler
                        multiple times, the pass name should be appended with a sequential number starting from 1. range-list
                        is a comma-separated list of function ranges or assembler names. Each range is a number pair
                        separated by a colon. The range is inclusive in both ends. If the range is trivial, the number pair
                        can be simplified as a single number. If the function's cgraph node's uid falls within one of the
                        specified ranges, the pass is disabled for that function. The uid is shown in the function header of
                        a dump file, and the pass names can be dumped by using option -fdump-passes.

                -fdisable-tree-pass

                -fdisable-tree-pass=range-list
                        Disable tree pass pass. See -fdisable-rtl for the description of option arguments.

                -fenable-ipa-pass
                        Enable IPA pass pass. pass is the pass name. If the same pass is statically invoked in the compiler
                        multiple times, the pass name should be appended with a sequential number starting from 1.

                -fenable-rtl-pass

                -fenable-rtl-pass=range-list
                        Enable RTL pass pass. See -fdisable-rtl for option argument description and examples.

                -fenable-tree-pass

                -fenable-tree-pass=range-list
                        Enable tree pass pass. See -fdisable-rtl for the description of option arguments.

           Here are some examples showing uses of these options.

          
           # disable ccp1 for all functions
              -fdisable-tree-ccp1
           # disable complete unroll for function whose cgraph node uid is 1
              -fenable-tree-cunroll=1
           # disable gcse2 for functions at the following ranges [1,1],
           # [300,400], and [400,1000]
           # disable gcse2 for functions foo and foo2
              -fdisable-rtl-gcse2=foo,foo2
           # disable early inlining
              -fdisable-tree-einline
           # disable ipa inlining
              -fdisable-ipa-inline
           # enable tree full unroll
              -fenable-tree-unroll
          
     

   -dletters

   -fdump-rtl-pass
           Says to make debugging dumps during compilation at times specified by letters. This is used for debugging the
           RTL-based passes of the compiler. The file names for most of the dumps are made by appending a pass number and a
           word to the dumpname, and the files are created in the directory of the output file. Note that the pass number is
           computed statically as passes get registered into the pass manager. Thus the numbering is not related to the
           dynamic order of execution of passes. In particular, a pass installed by a plugin could have a number over 200
           even if it executed quite early. dumpname is generated from the name of the output file, if explicitly specified
           and it is not an executable, otherwise it is the basename of the source file. These switches may have different
           effects when -E is used for preprocessing.

           Debug dumps can be enabled with a -fdump-rtl switch or some -d option letters. Here are the possible letters for
           use in pass and letters, and their meanings:

                -fdump-rtl-alignments
                        Dump after branch alignments have been computed.

                -fdump-rtl-asmcons
                        Dump after fixing rtl statements that have unsatisfied in/out constraints.

                -fdump-rtl-auto_inc_dec
                        Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto
                        dec instructions.

                -fdump-rtl-barriers
                        Dump after cleaning up the barrier instructions.

                -fdump-rtl-bbpart
                        Dump after partitioning hot and cold basic blocks.

                -fdump-rtl-bbro
                        Dump after block reordering.

                -fdump-rtl-btl1

                -fdump-rtl-btl2
                        -fdump-rtl-btl1 and -fdump-rtl-btl2 enable dumping after the two branch target load optimization
                        passes.

                -fdump-rtl-bypass
                        Dump after jump bypassing and control flow optimizations.

                -fdump-rtl-combine
                        Dump after the RTL instruction combination pass.

                -fdump-rtl-compgotos
                        Dump after duplicating the computed gotos.

                -fdump-rtl-ce1

                -fdump-rtl-ce2

                -fdump-rtl-ce3
                        -fdump-rtl-ce1, -fdump-rtl-ce2, and -fdump-rtl-ce3 enable dumping after the three if conversion
                        passes.

                -fdump-rtl-cprop_hardreg
                        Dump after hard register copy propagation.

                -fdump-rtl-csa
                        Dump after combining stack adjustments.

                -fdump-rtl-cse1

                -fdump-rtl-cse2
                        -fdump-rtl-cse1 and -fdump-rtl-cse2 enable dumping after the two common sub-expression elimination
                        passes.

                -fdump-rtl-dce
                        Dump after the standalone dead code elimination passes.

                -fdump-rtl-dbr
                        Dump after delayed branch scheduling.

                -fdump-rtl-dce1

                -fdump-rtl-dce2
                        -fdump-rtl-dce1 and -fdump-rtl-dce2 enable dumping after the two dead store elimination passes.

                -fdump-rtl-eh
                        Dump after finalization of EH handling code.

                -fdump-rtl-eh_ranges
                        Dump after conversion of EH handling range regions.

                -fdump-rtl-expand
                        Dump after RTL generation.

                -fdump-rtl-fwprop1

                -fdump-rtl-fwprop2
                        -fdump-rtl-fwprop1 and -fdump-rtl-fwprop2 enable dumping after the two forward propagation passes.

                -fdump-rtl-gcse1

                -fdump-rtl-gcse2
                        -fdump-rtl-gcse1 and -fdump-rtl-gcse2 enable dumping after global common subexpression elimination.

                -fdump-rtl-init-regs
                        Dump after the initialization of the registers.

                -fdump-rtl-initvals
                        Dump after the computation of the initial value sets.

                -fdump-rtl-into_cfglayout
                        Dump after converting to cfglayout mode.

                -fdump-rtl-ira
                        Dump after iterated register allocation.

                -fdump-rtl-jump
                        Dump after the second jump optimization.

                -fdump-rtl-loop2
                        -fdump-rtl-loop2 enables dumping after the rtl loop optimization passes.

                -fdump-rtl-mach
                        Dump after performing the machine dependent reorganization pass, if that pass exists.

                -fdump-rtl-mode_sw
                        Dump after removing redundant mode switches.

                -fdump-rtl-rnreg
                        Dump after register renumbering.

                -fdump-rtl-outof_cfglayout
                        Dump after converting from cfglayout mode.

                -fdump-rtl-peephole2
                        Dump after the peephole pass.

                -fdump-rtl-postreload
                        Dump after post-reload optimizations.

                -fdump-rtl-pro_and_epilogue
                        Dump after generating the function prologues and epilogues.

                -fdump-rtl-regmove
                        Dump after the register move pass.

                -fdump-rtl-sched1

                -fdump-rtl-sched2
                        -fdump-rtl-sched1 and -fdump-rtl-sched2 enable dumping after the basic block scheduling passes.

                -fdump-rtl-see
                        Dump after sign extension elimination.

                -fdump-rtl-seqabstr
                        Dump after common sequence discovery.

                -fdump-rtl-shorten
                        Dump after shortening branches.

                -fdump-rtl-sibling
                        Dump after sibling call optimizations.

                -fdump-rtl-split1

                -fdump-rtl-split2

                -fdump-rtl-split3

                -fdump-rtl-split4

                -fdump-rtl-split5
                        -fdump-rtl-split1, -fdump-rtl-split2, -fdump-rtl-split3, -fdump-rtl-split4 and -fdump-rtl-split5
                        enable dumping after five rounds of instruction splitting.

                -fdump-rtl-sms
                        Dump after modulo scheduling. This pass is only run on some architectures.

                -fdump-rtl-stack
                        Dump after conversion from GCC's "flat register file" registers to the x87's stack-like registers.
                        This pass is only run on x86 variants.

                -fdump-rtl-subreg1

                -fdump-rtl-subreg2
                        -fdump-rtl-subreg1 and -fdump-rtl-subreg2 enable dumping after the two subreg expansion passes.

                -fdump-rtl-unshare
                        Dump after all rtl has been unshared.

                -fdump-rtl-vartrack
                        Dump after variable tracking.

                -fdump-rtl-vregs
                        Dump after converting virtual registers to hard registers.

                -fdump-rtl-web
                        Dump after live range splitting.

                -fdump-rtl-regclass

                -fdump-rtl-subregs_of_mode_init

                -fdump-rtl-subregs_of_mode_finish

                -fdump-rtl-dfinit

                -fdump-rtl-dfinish
                        These dumps are defined but always produce empty files.

                -fdump-rtl-all
                        Produce all the dumps listed above.

                -dA
                        Annotate the assembler output with miscellaneous debugging information.

                -dD
                        Dump all macro definitions, at the end of preprocessing, in addition to normal output.

                -dH
                        Produce a core dump whenever an error occurs.

                -dm
                        Print statistics on memory usage, at the end of the run, to standard error.

                -dp
                        Annotate the assembler output with a comment indicating which pattern and alternative is used. The
                        length of each instruction is also printed.

                -dP
                        Dump the RTL in the assembler output as a comment before each instruction. Also turns on -dp
                        annotation.

                -dv
                        For each of the other indicated dump files (-fdump-rtl-pass), dump a representation of the control
                        flow graph suitable for viewing with VCG to file.pass.vcg.

                -dx
                        Just generate RTL for a function instead of compiling it. Usually used with -fdump-rtl-expand.

   -fdump-noaddr
           When doing debugging dumps, suppress address output. This makes it more feasible to use diff on debugging dumps
           for compiler invocations with different compiler binaries and/or different text / bss / data / heap / stack / dso
           start locations.

   -fdump-unnumbered
           When doing debugging dumps, suppress instruction numbers and address output. This makes it more feasible to use
           diff on debugging dumps for compiler invocations with different options, in particular with and without -g.

   -fdump-unnumbered-links
           When doing debugging dumps (see -d option above), suppress instruction numbers for the links to the previous and
           next instructions in a sequence.

   -fdump-translation-unit (C++ only)

   -fdump-translation-unit-options (C++ only)
           Dump a representation of the tree structure for the entire translation unit to a file. The file name is made by
           appending .tu to the source file name, and the file is created in the same directory as the output file. If the
           `-options' form is used, options controls the details of the dump as described for the -fdump-tree options.

   -fdump-class-hierarchy (C++ only)

   -fdump-class-hierarchy-options (C++ only)
           Dump a representation of each class's hierarchy and virtual function table layout to a file. The file name is made
           by appending .class to the source file name, and the file is created in the same directory as the output file. If
           the `-options' form is used, options controls the details of the dump as described for the -fdump-tree options.

   -fdump-ipa-switch
           Control the dumping at various stages of inter-procedural analysis language tree to a file. The file name is
           generated by appending a switch specific suffix to the source file name, and the file is created in the same
           directory as the output file. The following dumps are possible:

                `all'
                        Enables all inter-procedural analysis dumps.

                `cgraph'
                        Dumps information about call-graph optimization, unused function removal, and inlining decisions.

                `inline'
                        Dump after function inlining.

   -fdump-passes
           Dump the list of optimization passes that are turned on and off by the current command-line options.

   -fdump-statistics-option
           Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix
           ending in `.statistics' to the source file name, and the file is created in the same directory as the output file.
           If the `-option' form is used, `-stats' causes counters to be summed over the whole compilation unit while
           `-details' dumps every event as the passes generate them. The default with no option is to sum counters for each
           function compiled.

   -fdump-tree-switch

   -fdump-tree-switch-options
           Control the dumping at various stages of processing the intermediate language tree to a file. The file name is
           generated by appending a switch specific suffix to the source file name, and the file is created in the same
           directory as the output file. If the `-options' form is used, options is a list of `-' separated options which
           control the details of the dump. Not all options are applicable to all dumps; those that are not meaningful are
           ignored. The following options are available

                `address'
                        Print the address of each node. Usually this is not meaningful as it changes according to the
                        environment and source file. Its primary use is for tying up a dump file with a debug environment.

                `asmname'
                        If DECL_ASSEMBLER_NAME has been set for a given decl, use that in the dump instead of DECL_NAME. Its
                        primary use is ease of use working backward from mangled names in the assembly file.

                `slim'
                        Inhibit dumping of members of a scope or body of a function merely because that scope has been
                        reached. Only dump such items when they are directly reachable by some other path. When dumping
                        pretty-printed trees, this option inhibits dumping the bodies of control structures.

                `raw'
                        Print a raw representation of the tree. By default, trees are pretty-printed into a C-like
                        representation.

                `details'
                        Enable more detailed dumps (not honored by every dump option).

                `stats'
                        Enable dumping various statistics about the pass (not honored by every dump option).

                `blocks'
                        Enable showing basic block boundaries (disabled in raw dumps).

                `vops'
                        Enable showing virtual operands for every statement.

                `lineno'
                        Enable showing line numbers for statements.

                `uid'
                        Enable showing the unique ID (DECL_UID) for each variable.

                `verbose'
                        Enable showing the tree dump for each statement.

                `eh'
                        Enable showing the EH region number holding each statement.

                `scev'
                        Enable showing scalar evolution analysis details.

                `all'
                        Turn on all options, except raw, slim, verbose and lineno.

           The following tree dumps are possible:

                `original'
                        Dump before any tree based optimization, to file.original.

                `optimized'
                        Dump after all tree based optimization, to file.optimized.

                `gimple'
                        Dump each function before and after the gimplification pass to a file. The file name is made by
                        appending .gimple to the source file name.

                `cfg'
                        Dump the control flow graph of each function to a file. The file name is made by appending .cfg to
                        the source file name.

                `vcg'
                        Dump the control flow graph of each function to a file in VCG format. The file name is made by
                        appending .vcg to the source file name. Note that if the file contains more than one function, the
                        generated file cannot be used directly by VCG. You must cut and paste each function's graph into its
                        own separate file first.

                `ch'
                        Dump each function after copying loop headers. The file name is made by appending .ch to the source
                        file name.

                `ssa'
                        Dump SSA related information to a file. The file name is made by appending .ssa to the source file
                        name.

                `alias'
                        Dump aliasing information for each function. The file name is made by appending .alias to the source
                        file name.

                `ccp'
                        Dump each function after CCP. The file name is made by appending .ccp to the source file name.

                `storeccp'
                        Dump each function after STORE-CCP. The file name is made by appending .storeccp to the source file
                        name.

                `pre'
                        Dump trees after partial redundancy elimination. The file name is made by appending .pre to the
                        source file name.

                `fre'
                        Dump trees after full redundancy elimination. The file name is made by appending .fre to the source
                        file name.

                `copyprop'
                        Dump trees after copy propagation. The file name is made by appending .copyprop to the source file
                        name.

                `store_copyprop'
                        Dump trees after store copy-propagation. The file name is made by appending .store_copyprop to the
                        source file name.

                `dce'
                        Dump each function after dead code elimination. The file name is made by appending .dce to the source
                        file name.

                `mudflap'
                        Dump each function after adding mudflap instrumentation. The file name is made by appending .mudflap
                        to the source file name.

                `sra'
                        Dump each function after performing scalar replacement of aggregates. The file name is made by
                        appending .sra to the source file name.

                `sink'
                        Dump each function after performing code sinking. The file name is made by appending .sink to the
                        source file name.

                `dom'
                        Dump each function after applying dominator tree optimizations. The file name is made by appending
                        .dom to the source file name.

                `dse'
                        Dump each function after applying dead store elimination. The file name is made by appending .dse to
                        the source file name.

                `phiopt'
                        Dump each function after optimizing PHI nodes into straightline code. The file name is made by
                        appending .phiopt to the source file name.

                `forwprop'
                        Dump each function after forward propagating single use variables. The file name is made by appending
                        .forwprop to the source file name.

                `copyrename'
                        Dump each function after applying the copy rename optimization. The file name is made by appending
                        .copyrename to the source file name.

                `nrv'
                        Dump each function after applying the named return value optimization on generic trees. The file name
                        is made by appending .nrv to the source file name.

                `vect'
                        Dump each function after applying vectorization of loops. The file name is made by appending .vect to
                        the source file name.

                `slp'
                        Dump each function after applying vectorization of basic blocks. The file name is made by appending
                        .slp to the source file name.

                `vrp'
                        Dump each function after Value Range Propagation (VRP). The file name is made by appending .vrp to
                        the source file name.

                `all'
                        Enable all the available tree dumps with the flags provided in this option.

   -ftree-vectorizer-verbose=n
           This option controls the amount of debugging output the vectorizer prints. This information is written to standard
           error, unless -fdump-tree-all or -fdump-tree-vect is specified, in which case it is output to the usual dump
           listing file, .vect. For n=0 no diagnostic information is reported. If n=1 the vectorizer reports each loop that
           got vectorized, and the total number of loops that got vectorized. If n=2 the vectorizer also reports
           non-vectorized loops that passed the first analysis phase (vect_analyze_loop_form) - i.e. countable, inner-most,
           single-bb, single-entry/exit loops. This is the same verbosity level that -fdump-tree-vect-stats uses. Higher
           verbosity levels mean either more information dumped for each reported loop, or same amount of information
           reported for more loops: if n=3, vectorizer cost model information is reported. If n=4, alignment related
           information is added to the reports. If n=5, data-references related information (e.g. memory dependences, memory
           access-patterns) is added to the reports. If n=6, the vectorizer reports also non-vectorized inner-most loops that
           did not pass the first analysis phase (i.e., may not be countable, or may have complicated control-flow). If n=7,
           the vectorizer reports also non-vectorized nested loops. If n=8, SLP related information is added to the reports.
           For n=9, all the information the vectorizer generates during its analysis and transformation is reported. This is
           the same verbosity level that -fdump-tree-vect-details uses.

   -frandom-seed=string
           This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have
           to be different in every compiled file. It is also used to place unique stamps in coverage data files and the
           object files that produce them. You can use the -frandom-seed option to produce reproducibly identical object
           files.

           The string should be different for every file you compile.

   -fsched-verbose=n
           On targets that use instruction scheduling, this option controls the amount of debugging output the scheduler
           prints. This information is written to standard error, unless -fdump-rtl-sched1 or -fdump-rtl-sched2 is specified,
           in which case it is output to the usual dump listing file, .sched1 or .sched2 respectively. However for n greater
           than nine, the output is always printed to standard error.

           For n greater than zero, -fsched-verbose outputs the same information as -fdump-rtl-sched1 and -fdump-rtl-sched2.
           For n greater than one, it also output basic block probabilities, detailed ready list information and unit/insn
           info. For n greater than two, it includes RTL at abort point, control-flow and regions info. And for n over four,
           -fsched-verbose also includes dependence info.

   -save-temps

   -save-temps=cwd
           Store the usual "temporary" intermediate files permanently; place them in the current directory and name them
           based on the source file. Thus, compiling foo.c with -c -save-temps produces files foo.i and foo.s, as well as
           foo.o. This creates a preprocessed foo.i output file even though the compiler now normally uses an integrated
           preprocessor.

           When used in combination with the -x command-line option, -save-temps is sensible enough to avoid over writing an
           input source file with the same extension as an intermediate file. The corresponding intermediate file may be
           obtained by renaming the source file before using -save-temps.

           If you invoke GCC in parallel, compiling several different source files that share a common base name in different
           subdirectories or the same source file compiled for multiple output destinations, it is likely that the different
           parallel compilers will interfere with each other, and overwrite the temporary files. For instance:

           gcc -save-temps -o outdir1/foo.o indir1/foo.c&
           gcc -save-temps -o outdir2/foo.o indir2/foo.c&
     

           may result in foo.i and foo.o being written to simultaneously by both compilers.

   -save-temps=obj
           Store the usual "temporary" intermediate files permanently. If the -o option is used, the temporary files are
           based on the object file. If the -o option is not used, the -save-temps=obj switch behaves like -save-temps.

           For example:

           gcc -save-temps=obj -c foo.c
           gcc -save-temps=obj -c bar.c -o dir/xbar.o
           gcc -save-temps=obj foobar.c -o dir2/yfoobar
     

           creates foo.i, foo.s, dir/xbar.i, dir/xbar.s, dir2/yfoobar.i, dir2/yfoobar.s, and dir2/yfoobar.o.

   -time[=file]
           Report the CPU time taken by each subprocess in the compilation sequence. For C source files, this is the compiler
           proper and assembler (plus the linker if linking is done).

           Without the specification of an output file, the output looks like this:

           # cc1 0.12 0.01
           # as 0.00 0.01
     

           The first number on each line is the "user time", that is time spent executing the program itself. The second
           number is "system time", time spent executing operating system routines on behalf of the program. Both numbers are
           in seconds.

           With the specification of an output file, the output is appended to the named file, and it looks like this:

           0.12 0.01 cc1 options
           0.00 0.01 as options
     

           The "user time" and the "system time" are moved before the program name, and the options passed to the program are
           displayed, so that one can later tell what file was being compiled, and with which options.

   -fvar-tracking
           Run variable tracking pass. It computes where variables are stored at each position in code. Better debugging
           information is then generated (if the debugging information format supports this information).

           It is enabled by default when compiling with optimization (-Os, -O, -O2, ...), debugging information (-g) and the
           debug info format supports it.

   -fvar-tracking-assignments
           Annotate assignments to user variables early in the compilation and attempt to carry the annotations over
           throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing.
           Use of -gdwarf-4 is recommended along with it.

           It can be enabled even if var-tracking is disabled, in which case annotations are created and maintained, but
           discarded at the end.

   -fvar-tracking-assignments-toggle
           Toggle -fvar-tracking-assignments, in the same way that -gtoggle toggles -g.

   -print-file-name=library
           Print the full absolute name of the library file library that would be used when linking-and don't do anything
           else. With this option, GCC does not compile or link anything; it just prints the file name.

   -print-multi-directory
           Print the directory name corresponding to the multilib selected by any other switches present in the command line.
           This directory is supposed to exist in GCC_EXEC_PREFIX.

   -print-multi-lib
           Print the mapping from multilib directory names to compiler switches that enable them. The directory name is
           separated from the switches by `;', and each switch starts with an `@' instead of the `-', without spaces between
           multiple switches. This is supposed to ease shell-processing.

   -print-multi-os-directory
           Print the path to OS libraries for the selected multilib, relative to some lib subdirectory. If OS libraries are
           present in the lib subdirectory and no multilibs are used, this is usually just ., if OS libraries are present in
           libsuffix sibling directories this prints e.g. ../lib64, ../lib or ../lib32, or if OS libraries are present in
           lib/subdir subdirectories it prints e.g. amd64, sparcv9 or ev6.

   -print-prog-name=program
           Like -print-file-name, but searches for a program such as `cpp'.

   -print-libgcc-file-name
           Same as -print-file-name=libgcc.a.

           This is useful when you use -nostdlib or -nodefaultlibs but you do want to link with libgcc.a. You can do

           gcc -nostdlib files... `gcc -print-libgcc-file-name`
     

   -print-search-dirs
           Print the name of the configured installation directory and a list of program and library directories gcc
           searches-and don't do anything else.

           This is useful when gcc prints the error message `installation problem, cannot exec cpp0: No such file or
           directory'. To resolve this you either need to put cpp0 and the other compiler components where gcc expects to
           find them, or you can set the environment variable GCC_EXEC_PREFIX to the directory where you installed them.
           Don't forget the trailing `/'. See Environment Variables.

   -print-sysroot
           Print the target sysroot directory that is used during compilation. This is the target sysroot specified either at
           configure time or using the --sysroot option, possibly with an extra suffix that depends on compilation options.
           If no target sysroot is specified, the option prints nothing.

   -print-sysroot-headers-suffix
           Print the suffix added to the target sysroot when searching for headers, or give an error if the compiler is not
           configured with such a suffix-and don't do anything else.

   -dumpmachine
           Print the compiler's target machine (for example, `i686-pc-linux-gnu')-and don't do anything else.

   -dumpversion
           Print the compiler version (for example, `3.0')-and don't do anything else.

   -dumpspecs
           Print the compiler's built-in specs-and don't do anything else. (This is used when GCC itself is being built.) See
           Spec Files.

   -feliminate-unused-debug-types
           Normally, when producing DWARF 2 output, GCC emits debugging information for all types declared in a compilation
           unit, regardless of whether or not they are actually used in that compilation unit. Sometimes this is useful, such
           as if, in the debugger, you want to cast a value to a type that is not actually used in your program (but is
           declared). More often, however, this results in a significant amount of wasted space. With this option, GCC avoids
           producing debug symbol output for types that are nowhere used in the source file being compiled.
